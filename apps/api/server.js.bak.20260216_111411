import Fastify from "fastify";
import multipart from "@fastify/multipart";
import { PrismaClient } from "@prisma/client";

import fs from "node:fs";
import fsp from "node:fs/promises";
import path from "node:path";
import crypto from "node:crypto";

import PDFDocument from "pdfkit";
import * as XLSX from "xlsx";

import PizZip from "pizzip";
import Docxtemplater from "docxtemplater";

// --------------------
// Config
// --------------------
const PORT = Number(process.env.PORT || 3001);
const HOST = process.env.HOST || "127.0.0.1";
const DATABASE_URL = process.env.DATABASE_URL || "";

const STORAGE_ROOT = path.resolve(process.cwd(), "storage", "audits");
const TEMPLATE_PATH = path.resolve(process.cwd(), "templates", "audit-template.docx");

const prisma = new PrismaClient();

const app = Fastify({ logger: true });

await app.register(multipart, {
  limits: { fileSize: 200 * 1024 * 1024 }, // 200MB (commercial-ish; tune later)
});

// --------------------
// Helpers: storage
// --------------------
async function ensureDir(dir) {
  await fsp.mkdir(dir, { recursive: true });
}

function auditsRoot() {
  return STORAGE_ROOT;
}

function kindToSubdir(kind) {
  const k = (kind || "").toLowerCase();
  if (k === "image") return "images";
  if (k === "video") return "video";
  if (k === "audio") return "audio";
  return "uploads";
}

function safeFilename(name) {
  const base = (name || "file").replace(/[^a-zA-Z0-9._-]/g, "_");
  return base.slice(0, 180);
}

function makeStorageKey({ auditId, kind, originalName }) {
  const ext = path.extname(originalName || "");
  const rand = crypto.randomBytes(8).toString("hex");
  const sub = kindToSubdir(kind);
  return path.join(auditId, "media", sub, `${Date.now()}_${rand}${ext}`);
}

function absPathForKey(storageKey) {
  return path.join(auditsRoot(), storageKey);
}

async function readUploadFileToBuffer(file) {
  const parts = [];
  for await (const chunk of file.file) parts.push(chunk);
  return Buffer.concat(parts);
}

// --------------------
// Helpers: parsing CSV
// --------------------
function parseCsvToRows(csvText) {
  const lines = csvText.split(/\r?\n/).filter(Boolean);
  if (lines.length === 0) return { header: [], rows: [] };

  const parseLine = (line) => {
    const out = [];
    let cur = "";
    let inQ = false;
    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (ch === '"' && line[i + 1] === '"') {
        cur += '"';
        i++;
        continue;
      }
      if (ch === '"') {
        inQ = !inQ;
        continue;
      }
      if (ch === "," && !inQ) {
        out.push(cur);
        cur = "";
        continue;
      }
      cur += ch;
    }
    out.push(cur);
    return out.map((s) => s.trim());
  };

  const header = parseLine(lines[0]);
  const rows = lines.slice(1).map(parseLine).map((cols) => {
    const obj = {};
    for (let i = 0; i < header.length; i++) obj[header[i]] = cols[i] ?? "";
    return obj;
  });

  return { header, rows };
}

function normalizeStatus(s) {
  const v = String(s || "").trim().toUpperCase();
  if (v === "PASS" || v === "OK") return "PASS";
  if (v === "FAIL" || v === "NG") return "FAIL";
  if (v === "NA" || v === "N/A") return "NA";
  return v ? v : "UNKNOWN";
}

function computeSummary(items) {
  const summary = { total: items.length, pass: 0, fail: 0, na: 0, unknown: 0 };
  for (const it of items) {
    if (it.status === "PASS") summary.pass++;
    else if (it.status === "FAIL") summary.fail++;
    else if (it.status === "NA") summary.na++;
    else summary.unknown++;
  }
  return summary;
}

// --------------------
// Helpers: reports
// --------------------
function buildPdfBuffer({ title, summary, items }) {
  const doc = new PDFDocument({ size: "A4", margin: 50 });
  const chunks = [];
  doc.on("data", (d) => chunks.push(d));
  return new Promise((resolve, reject) => {
    doc.on("end", () => resolve(Buffer.concat(chunks)));
    doc.on("error", reject);

    doc.fontSize(18).text(title || "Audit Report", { align: "left" });
    doc.moveDown();

    doc.fontSize(12).text(`Total: ${summary.total}`);
    doc.text(`PASS: ${summary.pass}`);
    doc.text(`FAIL: ${summary.fail}`);
    doc.text(`N/A: ${summary.na}`);
    doc.text(`UNKNOWN: ${summary.unknown}`);
    doc.moveDown();

    doc.fontSize(12).text("Items:");
    doc.moveDown(0.5);

    for (const it of items) {
      doc.text(`${it.idx}. ${it.id} — ${it.status} — ${it.comment || ""}`);
    }

    doc.end();
  });
}

function buildXlsxBuffer({ sheetName, items }) {
  const wsData = [
    ["#", "Item", "Status", "Comment"],
    ...items.map((it) => [it.idx, it.id, it.status, it.comment || ""]),
  ];
  const ws = XLSX.utils.aoa_to_sheet(wsData);
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, sheetName || "Sheet1");
  return XLSX.write(wb, { type: "buffer", bookType: "xlsx" });
}

// --------------------
// Helpers: DOCX template rendering
// --------------------
function renderDocxFromTemplate({ templatePath, data }) {
  const content = fs.readFileSync(templatePath, "binary");
  const zip = new PizZip(content);

  const doc = new Docxtemplater(zip, {
    paragraphLoop: true,
    linebreaks: true,
  });

  doc.render(data);

  return doc.getZip().generate({ type: "nodebuffer" });
}

function makeDocxData({ audit, summary, items }) {
  return {
    title: audit.title || "Audit Report",
    site: audit.site || "",
    standard: audit.standard || "",
    auditor: audit.auditor || "",
    generatedAt: new Date().toISOString(),

    total: summary.total,
    pass: summary.pass,
    fail: summary.fail,
    na: summary.na,
    unknown: summary.unknown,

    items: items.map((it) => ({
      idx: it.idx,
      id: it.id,
      status: it.status,
      comment: it.comment || "",
    })),
  };
}

// --------------------
// Routes
// --------------------
app.get("/health", async () => {
  return {
    ok: true,
    service: "sc-audit-copilot",
    status: "running",
    dbUrlLoaded: Boolean(DATABASE_URL),
  };
});

// ---- Path B: Audits (Commercial flow) ----

// List audits
app.get("/audits", async (req, reply) => {
  const take = Math.min(Number(req.query?.take || 20), 100);
  const skip = Math.max(Number(req.query?.skip || 0), 0);

  const audits = await prisma.audit.findMany({
    take,
    skip,
    orderBy: { createdAt: "desc" },
    select: {
      id: true,
      createdAt: true,
      updatedAt: true,
      title: true,
      site: true,
      standard: true,
      auditor: true,
      sourceFile: true,
    },
  });

  return reply.send({ ok: true, take, skip, audits });
});

// Get one audit
app.get("/audits/:auditId", async (req, reply) => {
  const { auditId } = req.params;

  const audit = await prisma.audit.findUnique({
    where: { id: auditId },
    select: {
      id: true,
      createdAt: true,
      updatedAt: true,
      title: true,
      site: true,
      standard: true,
      auditor: true,
      sourceFile: true,
      mappingJson: true,
      reportJson: true,
    },
  });

  if (!audit) return reply.code(404).send({ ok: false, error: "Audit not found", auditId });
  return reply.send({ ok: true, audit });
});

// Create audit
app.post("/audits", async (req, reply) => {
  const body = req.body || {};
  const title = body.title || "Data Center Audit - Draft";
  const site = body.site || null;
  const standard = body.standard || "TBD";
  const auditor = body.auditor || null;

  const audit = await prisma.audit.create({
    data: { title, site, standard, auditor, sourceFile: null, mappingJson: null, reportJson: null },
    select: { id: true, createdAt: true, title: true, site: true, standard: true, auditor: true },
  });

  return reply.code(201).send({ ok: true, audit });
});

// Attach media to an audit (image/video/audio/uploads)
app.post("/audits/:auditId/media", async (req, reply) => {
  const { auditId } = req.params;
  const kind = String(req.query?.kind || "uploads");

  const audit = await prisma.audit.findUnique({ where: { id: auditId }, select: { id: true } });
  if (!audit) return reply.code(404).send({ ok: false, error: "Audit not found", auditId });

  const file = await req.file();
  if (!file) return reply.code(400).send({ ok: false, error: "No file uploaded" });

  const buf = await readUploadFileToBuffer(file);
  const originalName = safeFilename(file.filename || "file");
  const storageKey = makeStorageKey({ auditId, kind, originalName });
  const abs = absPathForKey(storageKey);

  await ensureDir(path.dirname(abs));
  await fsp.writeFile(abs, buf);

  const row = await prisma.mediaFile.create({
    data: {
      auditId,
      kind,
      filename: originalName,
      mime: file.mimetype || "application/octet-stream",
      sizeBytes: buf.length,
      storageKey,
      notes: null,
    },
    select: { id: true, kind: true, filename: true, mime: true, sizeBytes: true, storageKey: true },
  });

  return reply.send({ ok: true, auditId, mediaId: row.id, ...row });
});

// List media for an audit
app.get("/audits/:auditId/media", async (req, reply) => {
  const { auditId } = req.params;

  const audit = await prisma.audit.findUnique({ where: { id: auditId }, select: { id: true } });
  if (!audit) return reply.code(404).send({ ok: false, error: "Audit not found", auditId });

  const rows = await prisma.mediaFile.findMany({
    where: { auditId },
    orderBy: { createdAt: "desc" },
    select: {
      id: true,
      createdAt: true,
      kind: true,
      filename: true,
      mime: true,
      sizeBytes: true,
      storageKey: true,
    },
  });

  return reply.send({ ok: true, auditId, media: rows });
});

// Download media by mediaId
app.get("/media/:mediaId/download", async (req, reply) => {
  const { mediaId } = req.params;

  const row = await prisma.mediaFile.findUnique({
    where: { id: mediaId },
    select: { id: true, filename: true, mime: true, storageKey: true },
  });

  if (!row) return reply.code(404).send({ ok: false, error: "Media not found", mediaId });

  const abs = absPathForKey(row.storageKey);
  if (!fs.existsSync(abs)) return reply.code(404).send({ ok: false, error: "File missing on disk", abs });

  reply.header("Content-Type", row.mime || "application/octet-stream");
  reply.header("Content-Disposition", `attachment; filename="${row.filename || "download.bin"}"`);
  return reply.send(fs.createReadStream(abs));
});

// ---- Path A: quick from-upload generators (still useful for demos) ----

app.post("/report/from-upload", async (req, reply) => {
  const file = await req.file();
  if (!file) return reply.code(400).send({ ok: false, error: "No file uploaded" });

  const buf = await readUploadFileToBuffer(file);
  const filename = safeFilename(file.filename || "upload.csv");
  const text = buf.toString("utf8");

  const { header, rows } = parseCsvToRows(text);

  const mapping = { id: "Item", status: "Status", comment: "Comment" };
  const items = rows.map((r, idx) => ({
    idx: idx + 1,
    id: r[mapping.id] ?? "",
    status: normalizeStatus(r[mapping.status]),
    comment: r[mapping.comment] ?? "",
  }));

  const summary = computeSummary(items);

  const audit = await prisma.audit.create({
    data: {
      title: "Audit Report",
      site: null,
      standard: null,
      auditor: null,
      sourceFile: filename,
      mappingJson: mapping,
      reportJson: { sheet: "Sheet1", header, items, summary },
    },
    select: { id: true },
  });

  return reply.send({
    ok: true,
    auditId: audit.id,
    generatedAt: new Date().toISOString(),
    filename,
    sheet: "Sheet1",
    summary,
    mapping,
    preview: items.slice(0, 25),
  });
});

app.post("/report/pdf/from-upload", async (req, reply) => {
  const file = await req.file();
  if (!file) return reply.code(400).send({ ok: false, error: "No file uploaded" });

  const buf = await readUploadFileToBuffer(file);
  const text = buf.toString("utf8");
  const { rows } = parseCsvToRows(text);

  const mapping = { id: "Item", status: "Status", comment: "Comment" };
  const items = rows.map((r, idx) => ({
    idx: idx + 1,
    id: r[mapping.id] ?? "",
    status: normalizeStatus(r[mapping.status]),
    comment: r[mapping.comment] ?? "",
  }));
  const summary = computeSummary(items);

  const pdf = await buildPdfBuffer({ title: "Audit Report", summary, items });

  reply.header("Content-Type", "application/pdf");
  reply.header("Content-Disposition", `attachment; filename="audit-report.pdf"`);
  return reply.send(pdf);
});

app.post("/report/xlsx/from-upload", async (req, reply) => {
  const file = await req.file();
  if (!file) return reply.code(400).send({ ok: false, error: "No file uploaded" });

  const buf = await readUploadFileToBuffer(file);
  const text = buf.toString("utf8");
  const { rows } = parseCsvToRows(text);

  const mapping = { id: "Item", status: "Status", comment: "Comment" };
  const items = rows.map((r, idx) => ({
    idx: idx + 1,
    id: r[mapping.id] ?? "",
    status: normalizeStatus(r[mapping.status]),
    comment: r[mapping.comment] ?? "",
  }));

  const xlsx = buildXlsxBuffer({ sheetName: "Sheet1", items });

  reply.header(
    "Content-Type",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
  );
  reply.header("Content-Disposition", `attachment; filename="audit-report.xlsx"`);
  return reply.send(xlsx);
});

app.post("/report/docx/from-upload", async (req, reply) => {
  if (!fs.existsSync(TEMPLATE_PATH)) {
    return reply.code(500).send({ ok: false, error: "Template missing", expectedPath: TEMPLATE_PATH });
  }

  const file = await req.file();
  if (!file) return reply.code(400).send({ ok: false, error: "No file uploaded" });

  const buf = await readUploadFileToBuffer(file);
  const filename = safeFilename(file.filename || "upload.csv");
  const text = buf.toString("utf8");

  const { header, rows } = parseCsvToRows(text);

  const mapping = { id: "Item", status: "Status", comment: "Comment" };
  const items = rows.map((r, idx) => ({
    idx: idx + 1,
    id: r[mapping.id] ?? "",
    status: normalizeStatus(r[mapping.status]),
    comment: r[mapping.comment] ?? "",
  }));

  const summary = computeSummary(items);

  const audit = await prisma.audit.create({
    data: {
      title: "Audit Report",
      sourceFile: filename,
      mappingJson: mapping,
      reportJson: { sheet: "Sheet1", header, items, summary },
    },
    select: { id: true, title: true, site: true, standard: true, auditor: true },
  });

  const docxData = makeDocxData({ audit, summary, items });
  const out = renderDocxFromTemplate({ templatePath: TEMPLATE_PATH, data: docxData });

  reply.header("Content-Type", "application/vnd.openxmlformats-officedocument.wordprocessingml.document");
  reply.header("Content-Disposition", `attachment; filename="audit-report.docx"`);
  return reply.send(out);
});

app.get("/audits/:auditId/report.docx", async (req, reply) => {
  const { auditId } = req.params;

  if (!fs.existsSync(TEMPLATE_PATH)) {
    return reply.code(500).send({ ok: false, error: "Template missing", expectedPath: TEMPLATE_PATH });
  }

  const audit = await prisma.audit.findUnique({
    where: { id: auditId },
    select: { id: true, title: true, site: true, standard: true, auditor: true, reportJson: true },
  });
  if (!audit) return reply.code(404).send({ ok: false, error: "Audit not found", auditId });

  const report = audit.reportJson || {};
  const items = Array.isArray(report.items) ? report.items : [];
  const summary = report.summary || computeSummary(items);

  const docxData = makeDocxData({ audit, summary, items });
  const out = renderDocxFromTemplate({ templatePath: TEMPLATE_PATH, data: docxData });

  reply.header("Content-Type", "application/vnd.openxmlformats-officedocument.wordprocessingml.document");
  reply.header("Content-Disposition", `attachment; filename="audit-${auditId}.docx"`);
  return reply.send(out);
});

// --------------------
app.listen({ port: PORT, host: HOST }, (err, address) => {
  if (err) {
    app.log.error(err);
    process.exit(1);
  }
  console.log(`Server running at ${address}`);
});
